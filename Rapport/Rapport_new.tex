\documentclass[12pt,a4paper]{article}

%%% Packages %%%

%\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
%\usepackage{algorithm}
%\usepackage{algpseudocode}
\usepackage{setspace}
\usepackage[textfont={it}]{caption}
\usepackage{alg}
\usepackage{algorithmic}
%%% Environnement bigcenter : permet de centrer des images plus larges que \linewidth %%%
\makeatletter
\newskip\@bigflushglue \@bigflushglue = -100pt plus 1fil
\def\bigcenter{\trivlist \bigcentering\item\relax}
\def\bigcentering{\let\\\@centercr\rightskip\@bigflushglue
\leftskip\@bigflushglue
\parindent\z@\parfillskip\z@skip}
\def\endbigcenter{\endtrivlist}
\makeatother

\newcommand{\reporttitle}{\vspace{3mm} MPRO-ECMA}
\newcommand{\reportauthor}{Paulin \textsc{Jacquot}\\Roxane \textsc{Delpeyrat}}
\newcommand{\reportsubject}{Projet 2015-2016}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\setlength{\parskip}{1ex}

\newcommand{\bb}[1]{\mathbb{#1}}
\renewcommand{\cal}[1]{\mathcal{#1}}

%%% Début du rapport %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%% Page de garde %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
	\begin{center}
		\begin{minipage}[c]{0.50\textwidth}
			\begin{flushright}
				% logo 1
			\end{flushright}
		\end{minipage}
		\hfill
		\begin{minipage}[c]{0.50\textwidth}
			\begin{flushleft}
				% logo 2
			\end{flushleft}
		\end{minipage}
		
		\vspace{2cm}
		
		\textsc{\Large \reportsubject}\\[0.5cm]
		\HRule \\[0.4cm]
		{\huge \bfseries \reporttitle}\\[0.4cm]
		\HRule \\[1.5cm]
		\begin{minipage}[t]{0.35\textwidth}
			\begin{flushleft} \large
				\emph{Auteurs :}\\
					\reportauthor
			\end{flushleft}
		\end{minipage}
		\vfill
		{\large \today}
	\end{center}
\end{titlepage}

\newpage

\tableofcontents

\newpage

\section{Modèle mathématique}
%%% E1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ex.1 : écriture d'un programme linéaire}

1.1 On utilise des variables $x_{ij}$ pour $(i,j) \in M $, valant $1$ SSI la maille $(i,j)$ est selectionnée. Le programme s'écrit alors :

\begin{align}
\label{obj} max & \sum_{(ij)\in M} x_{ij} \\
s.c. \label{critere} \ & \dfrac{\sum H_{ij}^pC_{ij}^p x_{ij}}{\sum C_{ij}^p x_{ij}}+ \dfrac{\sum H_{ij}^a C_{ij}^a x_{ij}}{\sum C_{ij}^a x_{ij}}\geq 2 \\
& x_{ij}\in \{0,1\}
\end{align}

\vspace{0.5cm}

1.2 Pour linéariser la contrainte fractionnaire (\ref{critere}), on utilise les variables :

\begin{align*}
y=\dfrac{1}{\sum C_{ij}^p x_{ij}} \ \ & \ \  z =\dfrac{1}{\sum C_{ij}^a x_{ij}}
\end{align*}

ce qui donne les contraintes quadratiques :

\begin{align} \label{Cq}
 \sum C_{ij}^p y \cdot x_{ij} = 1 \ \ & \ \   \sum C_{ij}^a z \cdot x_{ij} = 1
\end{align}

On linéarise ensuite ces contraintes. Pour cela, introduisons les quantités :

\begin{align*}
M^{p} = \dfrac{1}{\underset{(i,j) \in M }{min} C_{ij}^p} \ \ & \ \ M^{a} = \dfrac{1}{\underset{(i,j) \in M }{min} C_{ij}^a} 
\end{align*}

bien définies car les coefficients $C^p $ et $C^a$ sont strictement positifs pour tout $(ij) \in M$.

En posant $u_{ij} = x_{ij} \cdot y$ et $v_{ij} = x_{ij} \cdot z$, les contraintes (\ref{Cq}) sont alors équivalentes à :

\begin{align} \label{Clin1}
\sum_{(i,j) \in M} & C^p_{ij}\cdot u_{ij} =1 \ \ & \ \ \sum_{(i,j) \in M} & C^a_{ij}\cdot v_{ij} =1 \  & \\
\label{Clin2} u_{ij} & \leq x_{ij} \cdot M^p \ \ & \ \  v_{ij} &\leq x_{ij} \cdot M^a, &\ \forall (i,j) \in M  \\
\label{Clin3} u_{ij} & \leq y  \ \ & \ \  v_{ij} & \leq z, &\ \forall (i,j) \in M  \\
\label{Clin4} u_{ij} & \geq (x_{ij}-1) \cdot M^p +y\ \ & \ \ v_{ij} & \geq (x_{ij}-1) \cdot M^a +z, & \forall (i,j) \in M \\
\label{Clin5} u_{ij} & \geq 0 \ \ & \ \  v_{ij} & \geq 0, &\ \forall (i,j) \in M  
\end{align}

La contrainte (2) se réécrit également de façon linéaire :

\begin{equation} \label{critereLin}
\sum H_{ij}^p C_{ij}^p u_{ij} + \sum H_{ij}^aC_{ij}^a v_{ij} \geq 2
\end{equation}

Le programme linéaire s'obtient avec les contraintes (\ref{critereLin}) et \ref{Clin1}, \ref{Clin2},\ref{Clin3},\ref{Clin4},\ref{Clin5} et la même fonction objectif : $$max \sum_{(ij)\in M} x_{ij}$$

\vspace{1cm}


%%% E1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ex.2 : modélisation de la connexité }

Définissons, pour chaque $h\in [| 0,n^2 |] $, les variables binaires $ l_{ijh} \forall (i,j) \in M$.
On modélise alors la connexité comme le suggère l'énoncé : il existe une et une seule maille ``racine''  de hauteur $h=0$ . Ensuite, chaque maille $(ij)$ sélectionnée se voit attribuer une hauteur $h$ (et alors $l_{ijh}=1$ ) et une maille est selectionnée avec hauteur $h>0$ si une de ses voisines est selectionnée avec hauteur $h-1$.

Pour toute maille selectionnée $(i,j)$, il existe donc un chemin empruntant des mailles selectionnées jusqu'à la maille racine de hauteur 0. La solution est donc étoilée par rapport à cette maille racine, donc connexe.

Les contraintes s'écrivent donc de la manière suivante : 

\begin{align} \label{Cconnex}
\sum_{(ij)\in M} l_{ij0} &= 1 \ \text{(une et une seule racine)} \\
\sum_{h=0}^{n^2} l_{ijh} &= x_{ij} , \ \forall (i,j) \in M \\
l_{ijh+1} & \leq l_{i-1jh} +l_{i+1jh} +l_{ij-1h} +l_{ij+1h}, \forall (i,j) \in M, \ h\in [|0, n^2 -1|] \\
\l_{ijh} & \in \{0,1\} , \ \forall (i,j) \in M, \forall h\in [|0, n^2|] 
\end{align}

Cela représentant un très grand nombre de variables et de contraintes (en $\mathcal{O}(n^4) $ ), on pourra ajouter les contraintes au fur et à mesure, seulement si elles sont violées.


\vspace{2cm}


\section{Résolution directe}

\subsection{Résolution frontale et borne}

Nous avons implémenté le modèle précédent en utilisant l'API Cplex C++. Le modèle permet la résolution exacte des plus petites instances (5x8), mais le nombre de variables est trop élevé pour les instances plus grandes.

Dans une heuristique plus évoluée, nous effectuons une première résolution du problème sans contraintes de connexités. La valeur optimale obtenue $M*$ donne ensuite une très bonne borne sur la hauteur maximale de l'arbre de connexité décrit dans la partie précédente (la borne triviale était de l'ordre de $n \times m$). La hauteur de l'arbre de peut en effet dépasser :

\[ h_{max} = \dfrac{1}{2} M* +1\]

 Cela permet ainsi de générer significativement moins de variables binaires correspondant aux contraintes de connexité.

Avec ce modèle, nous arrivons à résoudre quelques unes des instances 10x12, mais cette méthode n'est pas efficace pour les instances ayant une solution non connexe de valeur élevée (comme l'instance $10\_12\_1.dat$).

\vspace{0.5cm}

Le fait de connaître la valeur optimale $M*$ du problème relaché sans les contraintes de connexité nous donne aussi une borne supérieure de la solution du problème initiale. Cette borne fournit en pratique une aide très précieuse à Cplex qui n'est pas capable de génerer la coupe $\sum x_{i,j} \leq M* $.

Par exemple, la résolution de l'instance \textit{projet 5 8 1} prend 13 secondes avec cette coupe, mais plus de 30 minutes sans cette coupe.


Le tableau suivant donne les résultats obtenus par cette méthode sur les premières instances :

\begin{figure}
\centering
\[
\begin{array}{c|c|c|c}
\text{Instance} & M* \text{(non conn.)} & \text{Res connexe }& \text{CPU time (s)} \\\hline
projet 5 8 1 &24 & 24 & 0.356659\\ \hline
projet 5 8 2 &4 & 4 & 0.184414\\ \hline
projet 5 8 3 &30 & 30 & 0.644796\\ \hline
projet 5 8 4 &18 & 18 & 1.04376\\ \hline
projet 5 8 5 &40 & 40 & 0.08267\\ \hline
projet 5 8 6 &23 & 23 & 0.219315\\ \hline
projet 5 8 7 &30 & 30 & 13.5549\\ \hline
projet 5 8 8 &28 & 28 & 14.762\\ \hline
projet 5 8 9 &23 & 23 & 13.4261\\ \hline
projet 5 8 10 &40 & 40 & 0.077614
\end{array} \]

Total simulation time : 44.3763s.
\caption{Résolution directe avec arbre de connexité, sans Callback}
\end{figure}


\subsection{Ajouts successifs des contraintes de connexité}
Afin de résoudre plus rapidement le problème, nous avons tenté, comme dans la résolution typique du voyageur de commerce, d'ajouter les contraintes de connexités décrites dans la partie 1 au fur et à mesure de la résolution du problème, en vérifiant le problème de "séparation" à chaque résolution.

Cela se fait simplement en utilisant la méthode \textit{ILOLAZYCONSTRAINTCALLBACK} disponible dans l'API Cplex. Cependant, en pratique, cela n'amène pas à une résolution beaucoup plus rapide : beaucoup de contraintes doivent être ajoutées pour obtenir une solution connexe, et finalement, pour certaines instances, la résolution est plus longue que si l'on considère toutes les contraintes de connexité dès le départ.

Cette méthode ne permet donc pas de résoudre les instances plus larges que 10x12.

\subsection{Minimisation des bords}

Nous avons également implémenté une méthode heuristique de minimisation des bords de la solution obtenue.

La méthode consiste à introduire $(n+1) \cdot m + n\cdot (m+1) $ variables binaires supplémentaires $e^h_{i,j}$ et $e^v_{i,j}$ correspondant aux arêtes horizontales et verticales de chaque case du damier. La variable $e_{i,j}$ vaut 1 SSI elle définit un "bord" de la solution, ce qui se traduit par les contraintes: 
\begin{align}
e^h_{i,j}\geq x_{i,j} - x_{i-1,j} \\
e^h_{i,j}\geq x_{i-1,j} - x_{i,j} \\
e^v_{i,j}\geq x_{i,j} - x_{i,j-1} \\
e^v_{i,j}\geq x_{i,j-1} - x_{i,j}
\end{align}

Comme une case sélectionnée dans la solution ``rajoute'' au plus deux bords, on utilise maintenant la fonction objectif :

$$ \sum_{i,j} x_{i,j} - \alpha \sum_{i,j} \left( e^h_{i,j} + e^v_{i,j} \right)$$

En pratique, nous avons pris $\alpha= 0.49$.
Cette méthode permet une résolution assez rapide et optimale sur les premières instances, mais ne permet toujours pas d'obtenir la résolution exacte des instances 10x12 en général.

Les résultats pour les premières instances sont regroupés dans le tableau suivant (figure \ref{tabMinEdges}).


\begin{figure}[H]
\centering

\[
\begin{array}{c|c|c|c}
\text{Instance} & M* \text{(non conn.)} & \text{Res connexe }& \text{CPU time (s)} \\\hline
projet 5 8 1 &24 & 24 & 0.889101\\ \hline
projet 5 8 2 &4 & 4 & 0.695555\\ \hline
projet 5 8 3 &30 & 30 & 0.785902\\ \hline
projet 5 8 4 &18 & 18 & 0.602633\\ \hline
projet 5 8 5 &40 & 40 & 0.013569\\ \hline
projet 5 8 6 &23 & 23 & 0.741241\\ \hline
projet 5 8 7 &30 & 30 & 7.70596\\ \hline
projet 5 8 8 &28 & 28 & 0.436938\\ \hline
projet 5 8 9 &23 & 23 & 1.18512\\ \hline
projet 5 8 10 &40 & 40 & 0.01264\\ \hline
\end{array}\]
Total simulation time : 13.0807s.
\end{array}
\]
\label{tabMinEdges}
\caption{Résolution directe avec minimisation des bords.}
\end{figure}


\section{Résolution par recuit simulé}
\subsection{Présentation de l'algorithme}
Le recuit simulé est une métaheuristique assez courante mais efficace même si la paramétrisation peut se révéler difficile.\\
Dans l'implémentation de l'algorithme, nous avons choisi de n'examiner que les solutions connexes car construire une solution connexe est difficile. Les fonctions de voisinages sont donc implémentées pour ne générer que des solutions connexes.\\ 
Par contre, on accepte de considérer les solutions ne respectant la contrainte fractionnaire liée au relief (voir la description du problème dans la première partie contrainte \ref{critere}).

Voici l'algorithme du recuit simulé:
\begin{algorithm}
	\caption{Algorithme du recuit}
	\begin{algorithmic}[1]
		\STATE Soit x une solution initiale.
		\STATE $x_{max} \gets x$
		\STATE $T\gets T_{init}$
		\FOR{k allant de 0 à $K_{max}$}
		\FOR{r allant de 0 à $R_{max}$}
		\STATE Générer une solution x' dans le voisinage de la solution courante x de manière aléatoire
		\STATE Reconstruire une solution admissible à partir de x'.
		\IF{$f(x')>f(x)$}
		\STATE $x gets x'$
		\STATE Soit f la fonction objectif.
		\IF{$f(x')>f(x_{max})$}
		\STATE $x_{max} \gets x'$
		\ENDIF
		\ELSE
		\STATE On tire q un nombre aléatoire.
		\STATE $e\gets \exp{\frac{f(x')-f(x)}{T}}$
		\IF {$q<e$}
		\STATE $x \gets x'$
		\ENDIF
		\ENDIF
		\ENDFOR
		\STATE $T\gets T*\phi$
		\IF{aucun changement de maximum à cette itération}
		\STATE break
		\ENDIF
		\ENDFOR
	\end{algorithmic}
\end{algorithm}
\subsection{Description des voisinages utilisés}
En plus du choix des paramètres, le voisinage utilisé influence l'efficacité de l'algorithme. La première idée a été de créer un voisinage constitué de toutes les solutions différant de 1 par rapport à la solution initiale et de l'évaluer si la solution obtenue était connexe. Cette solution n'est pas idéale dans le cas où il y a peu de cases dont la valeur puisse être changée tout en gardant la connexité de la solution.\\
La fonction de voisinage implémentée commence donc par voir si on peut ajouter à la solution une case dont la somme des coefficients $H-a[i][j]+H_p[i][j]>=2$. Si oui, la solution est générée en ajoutant toutes les cases répondant à ce critère. Si ce n'est pas le cas, l'algorithme tire au hasard une des cases parmi celles à 1 dans la solution d'origine et les voisines de celles-ci. Si la solution obtenue en changeant la valeur de la case tirée au sort est connexe alors la fonction de voisinage renvoie la solution obtenue. Sinon elle tire au sort une autre case.
\subsection{Résultats obtenus}
L'algorithme est assez efficace et trouve une bonne solution en moins de quelques secondes pour les petites instances et en moins de 2 minutes pour les plus grandes même s'il ne trouve pas toujours le maximum.\\
>>>>>>> 7d56ca5b611a2f669dd91804db5a120731aad5fb
\end{document}